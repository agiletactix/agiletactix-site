---
// Particle Network Animation Component
// Creates floating particles that connect when nearby
---

<canvas id="particle-canvas" class="absolute inset-0 w-full h-full"></canvas>

<script>
  const canvas = document.getElementById('particle-canvas') as HTMLCanvasElement;
  const ctx = canvas.getContext('2d');

  if (ctx) {
    // Configuration
    const particleCount = 80;
    const connectionDistance = 150;
    const particleSpeed = 0.5;

    // Desktop visibility boost (lg: 1024px+)
    // Subtle increase: lines 0.4 → 0.5, particles 0.35 → 0.45
    const isDesktop = () => window.innerWidth >= 1024;
    const getLineOpacity = () => isDesktop() ? 0.5 : 0.4;
    const getParticleOpacity = () => isDesktop() ? 0.45 : 0.35;

    interface Particle {
      x: number;
      y: number;
      vx: number;
      vy: number;
      radius: number;
    }

    let particles: Particle[] = [];
    let animationId: number;

    // Resize canvas to fill container
    function resizeCanvas() {
      const container = canvas.parentElement;
      if (container) {
        canvas.width = container.offsetWidth;
        canvas.height = container.offsetHeight;
      }
    }

    // Initialize particles
    function initParticles() {
      particles = [];
      for (let i = 0; i < particleCount; i++) {
        particles.push({
          x: Math.random() * canvas.width,
          y: Math.random() * canvas.height,
          vx: (Math.random() - 0.5) * particleSpeed,
          vy: (Math.random() - 0.5) * particleSpeed,
          radius: Math.random() * 2 + 1
        });
      }
    }

    // Draw a single particle
    function drawParticle(p: Particle) {
      if (!ctx) return;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
      ctx.fillStyle = `rgba(37, 99, 235, ${getParticleOpacity()})`;
      ctx.fill();
    }

    // Draw connection line between two particles
    function drawConnection(p1: Particle, p2: Particle, distance: number) {
      if (!ctx) return;
      const opacity = 1 - (distance / connectionDistance);
      ctx.beginPath();
      ctx.moveTo(p1.x, p1.y);
      ctx.lineTo(p2.x, p2.y);
      ctx.strokeStyle = `rgba(37, 99, 235, ${opacity * getLineOpacity()})`;
      ctx.lineWidth = 1;
      ctx.stroke();
    }

    // Update particle position
    function updateParticle(p: Particle) {
      p.x += p.vx;
      p.y += p.vy;

      // Bounce off edges
      if (p.x < 0 || p.x > canvas.width) p.vx *= -1;
      if (p.y < 0 || p.y > canvas.height) p.vy *= -1;

      // Keep particles in bounds
      p.x = Math.max(0, Math.min(canvas.width, p.x));
      p.y = Math.max(0, Math.min(canvas.height, p.y));
    }

    // Main animation loop
    function animate() {
      if (!ctx) return;

      // Clear canvas
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Update and draw particles
      for (let i = 0; i < particles.length; i++) {
        const particleI = particles[i]!;
        updateParticle(particleI);
        drawParticle(particleI);

        // Draw connections to nearby particles
        for (let j = i + 1; j < particles.length; j++) {
          const particleJ = particles[j]!;
          const dx = particleI.x - particleJ.x;
          const dy = particleI.y - particleJ.y;
          const distance = Math.sqrt(dx * dx + dy * dy);

          if (distance < connectionDistance) {
            drawConnection(particleI, particleJ, distance);
          }
        }
      }

      animationId = requestAnimationFrame(animate);
    }

    // Handle resize
    function handleResize() {
      resizeCanvas();
      initParticles();
    }

    // Initialize
    resizeCanvas();
    initParticles();
    animate();

    // Listen for resize
    window.addEventListener('resize', handleResize);

    // Cleanup on page navigation (for Astro)
    document.addEventListener('astro:before-swap', () => {
      cancelAnimationFrame(animationId);
      window.removeEventListener('resize', handleResize);
    });
  }
</script>
